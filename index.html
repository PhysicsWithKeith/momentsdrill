<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moments Drill - Physics Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #FF6B35;
            --secondary: #004E89;
            --accent: #F7B801;
            --success: #2EC4B6;
            --danger: #E71D36;
            --bg-light: #FFF8F0;
            --text-dark: #16213E;
            --shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            color: var(--text-dark);
            overflow-x: hidden;
            padding: 20px 0;
        }

        .bg-animation { position: fixed; width: 100%; height: 100%; top:0; left:0; z-index:0; overflow:hidden; pointer-events:none; }
        .particle { position: absolute; background: rgba(255,255,255,0.1); border-radius: 50%; animation: float 20s infinite; }
        @keyframes float { 0%,100% { transform: translateY(0) rotate(0deg); } 50% { transform: translateY(-100px) rotate(180deg); } }

        .container { position:relative; z-index:1; max-width: 1100px; width: 97%; margin: 0 auto; }

        .screen { display: none; background: var(--bg-light); border-radius: 24px; padding: 36px; box-shadow: var(--shadow); animation: slideIn 0.5s ease-out; }
        .screen.active { display: block; }
        @keyframes slideIn { from { opacity:0; transform:translateY(30px); } to { opacity:1; transform:translateY(0); } }

        h1 { font-size: clamp(1.8rem,5vw,3rem); color: var(--primary); text-align:center; margin-bottom:16px; font-weight:900; letter-spacing:-1px; }
        h2 { font-size:1.6rem; color:var(--secondary); margin-bottom:16px; font-weight:800; }

        .btn { background:var(--primary); color:white; border:none; padding:14px 28px; font-size:1.1rem; border-radius:12px; cursor:pointer; transition:all 0.3s; font-weight:800; box-shadow:0 4px 15px rgba(255,107,53,0.4); text-transform:uppercase; letter-spacing:1px; font-family:'Nunito',sans-serif; }
        .btn:hover { transform:translateY(-2px); box-shadow:0 6px 20px rgba(255,107,53,0.6); }
        .btn:active { transform:translateY(0); }
        .btn.secondary { background:var(--secondary); box-shadow:0 4px 15px rgba(0,78,137,0.4); }
        .btn.secondary:hover { box-shadow:0 6px 20px rgba(0,78,137,0.6); }
        .btn.small { padding:9px 18px; font-size:0.9rem; }

        /* Intro screen */
        .intro-content { text-align:center; }
        .rules { background:white; padding:28px; border-radius:16px; margin:24px 0; text-align:left; box-shadow:0 4px 12px rgba(0,0,0,0.08); }
        .rules h3 { color:var(--secondary); margin-bottom:12px; font-size:1.2rem; font-weight:800; }
        .rules ul { margin-left:22px; line-height:1.9; }
        .rules li { margin-bottom:8px; }
        .difficulty-selector { display:flex; gap:18px; justify-content:center; margin-top:24px; flex-wrap:wrap; }
        .difficulty-btn { flex:1; min-width:200px; max-width:280px; padding:28px; background:white; border:4px solid var(--primary); border-radius:16px; cursor:pointer; transition:all 0.3s; }
        .difficulty-btn:hover { transform:scale(1.05); border-color:var(--secondary); box-shadow:0 8px 24px rgba(0,0,0,0.15); }
        .difficulty-btn h3 { color:var(--primary); font-size:1.6rem; margin-bottom:8px; font-weight:800; }
        .difficulty-btn p { color:var(--text-dark); font-size:0.9rem; }

        /* Game header */
        .game-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:16px; flex-wrap:wrap; gap:12px; }
        .timer-section { display:flex; align-items:center; gap:12px; }
        .timer { font-family:'JetBrains Mono',monospace; font-size:1.8rem; font-weight:700; color:var(--secondary); background:white; padding:8px 18px; border-radius:12px; box-shadow:0 2px 8px rgba(0,0,0,0.1); min-width:100px; text-align:center; }
        .timer.warning { color:var(--danger); animation:pulse 1s infinite; }
        @keyframes pulse { 0%,100% { transform:scale(1); } 50% { transform:scale(1.05); } }
        .score-display { font-size:1.6rem; font-weight:800; color:var(--accent); background:white; padding:8px 18px; border-radius:12px; box-shadow:0 2px 8px rgba(0,0,0,0.1); }

        /* Diagram layout: table left, canvas right */
        .canvas-container { background:white; border-radius:16px; padding:16px; margin:16px 0; box-shadow:0 4px 16px rgba(0,0,0,0.1); overflow-x:auto; }
        .diagram-layout { display:flex; flex-direction:row; gap:14px; align-items:flex-start; }

        /* Force table */
        .force-table-container { flex-shrink:0; width:268px; }
        .force-table { width:100%; border-collapse:collapse; font-size:0.88rem; border-radius:10px; overflow:hidden; box-shadow:0 2px 8px rgba(0,0,0,0.08); }
        .force-table th { background:var(--secondary); color:white; padding:9px 8px; text-align:center; font-weight:800; font-size:0.82rem; }
        .force-table td { padding:9px 8px; text-align:center; border-bottom:1px solid #e8edf5; transition:background 0.15s; }
        .force-table tr:last-child td { border-bottom:none; }
        .force-table tbody tr:hover, .force-table tbody tr.highlighted {
            background: rgba(255,107,53,0.13) !important;
        }
        .force-label-cell { display:flex; align-items:center; justify-content:center; gap:6px; font-weight:800; font-size:1rem; }
        .force-color-dot { width:10px; height:10px; border-radius:50%; flex-shrink:0; }
        .force-table .missing-val { color:var(--primary); font-weight:900; font-family:'JetBrains Mono',monospace; font-size:1.1rem; }
        .force-table .known-val { font-family:'JetBrains Mono',monospace; color:var(--text-dark); }

        /* Canvas */
        #gameCanvas { display:block; flex:1; min-width:0; cursor:crosshair; }

        /* Question section */
        .question-section { background:white; border-radius:16px; padding:22px; margin:14px 0; box-shadow:0 4px 16px rgba(0,0,0,0.1); }
        .question-text { font-size:1.2rem; color:var(--secondary); margin-bottom:16px; font-weight:800; }
        .input-section { display:flex; gap:12px; margin-bottom:16px; flex-wrap:wrap; align-items:center; }
        .answer-input { flex:1; min-width:130px; padding:13px; font-size:1.1rem; border:3px solid var(--secondary); border-radius:12px; outline:none; transition:all 0.3s; font-family:'JetBrains Mono',monospace; }
        .answer-input:focus { border-color:var(--primary); box-shadow:0 0 0 4px rgba(255,107,53,0.2); }
        .unit-select { padding:13px; font-size:1.1rem; border:3px solid var(--secondary); border-radius:12px; outline:none; cursor:pointer; background:white; min-width:120px; font-family:'Nunito',sans-serif; }
        .attempts { font-size:1rem; color:var(--text-dark); margin-bottom:12px; font-weight:700; }
        .attempts.low { color:var(--danger); }
        .feedback { padding:13px; border-radius:12px; margin-top:12px; font-weight:700; animation:slideIn 0.3s ease; }
        .feedback.correct { background:rgba(46,196,182,0.2); color:var(--success); border-left:4px solid var(--success); }
        .feedback.incorrect { background:rgba(231,29,54,0.15); color:var(--danger); border-left:4px solid var(--danger); }

        /* Accuracy gauge */
        .accuracy-gauge { margin:14px 0; text-align:center; }
        .gauge-container { width:200px; height:120px; margin:0 auto; position:relative; }
        .gauge-label { font-size:1rem; color:var(--secondary); margin-bottom:8px; font-weight:700; }

        /* End screen */
        .end-content { text-align:center; }
        .final-score { font-size:3.5rem; color:var(--primary); font-weight:900; margin:24px 0; font-family:'JetBrains Mono',monospace; }
        .stats-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(180px,1fr)); gap:16px; margin:24px 0; }
        .stat-card { background:white; padding:22px; border-radius:16px; box-shadow:0 4px 12px rgba(0,0,0,0.08); }
        .stat-value { font-size:2.2rem; font-weight:900; color:var(--secondary); margin-bottom:8px; font-family:'JetBrains Mono',monospace; }
        .stat-label { font-size:0.95rem; color:var(--text-dark); font-weight:700; }

        /* Modal */
        .modal-overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:1000; justify-content:center; align-items:center; }
        .modal-overlay.active { display:flex; }
        .modal-content { background:white; padding:36px; border-radius:20px; box-shadow:0 20px 60px rgba(0,0,0,0.3); max-width:380px; text-align:center; animation:modalSlideIn 0.3s ease-out; }
        @keyframes modalSlideIn { from { transform:scale(0.8); opacity:0; } to { transform:scale(1); opacity:1; } }
        .modal-content h3 { color:var(--secondary); margin-bottom:16px; font-size:1.4rem; font-weight:800; }
        .modal-buttons { display:flex; gap:12px; justify-content:center; margin-top:22px; }
        .modal-buttons .btn { flex:1; }

        @media(max-width:700px) {
            .screen { padding:16px; }
            .diagram-layout { flex-direction:column; }
            .force-table-container { width:100%; }
            #gameCanvas { width:100% !important; height:auto !important; }
        }
    </style>
</head>
<body>
    <div class="bg-animation" id="bgAnimation"></div>

    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <h3 id="modalTitle">Confirm</h3>
            <p id="modalMessage">Are you sure?</p>
            <div class="modal-buttons">
                <button class="btn secondary" onclick="closeModal()">Cancel</button>
                <button class="btn" id="modalConfirmBtn">Confirm</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Intro Screen -->
        <div id="introScreen" class="screen active">
            <div class="intro-content">
                <h1>‚ö° MOMENTS DRILL ‚ö°</h1>
                <h3 style="color:var(--secondary);margin-bottom:4px;">Physics With Keith</h3>
                <div class="rules">
                    <h3>üéØ How to Play</h3>
                    <ul>
                        <li>You have <strong>5 minutes</strong> to solve as many moments problems as possible</li>
                        <li>Each question shows a beam with a pivot and forces ‚Äî one value is <strong>missing</strong></li>
                        <li>The table on the left lists each force's distance, angle, and magnitude</li>
                        <li>Give answers to <strong>at least 2 significant figures</strong></li>
                        <li>You get <strong>3 attempts</strong> per question ‚Äî first-time correct scores most!</li>
                        <li><strong>Hover</strong> over a force arrow to highlight its row in the table</li>
                    </ul>
                </div>
                <h2>Choose Your Level</h2>
                <div class="difficulty-selector">
                    <div class="difficulty-btn" onclick="startGame('gcse')">
                        <h3>üìö GCSE</h3>
                        <p>Horizontal beam, perpendicular forces. Master the basics!</p>
                    </div>
                    <div class="difficulty-btn" onclick="startGame('alevel')">
                        <h3>üéì A-Level</h3>
                        <p>Tilted beam, forces at angles. For the brave!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" class="screen">
            <div class="game-header">
                <div class="timer-section">
                    <div class="timer" id="timer">5:00</div>
                    <button class="btn small secondary" onclick="endGameEarly()">End Early</button>
                </div>
                <div class="score-display">Score: <span id="score">0</span></div>
            </div>

            <div class="canvas-container">
                <div class="diagram-layout">
                    <div class="force-table-container">
                        <table class="force-table" id="forceTable">
                            <thead>
                                <tr>
                                    <th>Force</th>
                                    <th>Dist (m)</th>
                                    <th>Angle (¬∞)</th>
                                    <th>Mag (N)</th>
                                </tr>
                            </thead>
                            <tbody id="forceTableBody"></tbody>
                        </table>
                    </div>
                    <canvas id="gameCanvas" width="700" height="380"></canvas>
                </div>
            </div>

            <div class="question-section">
                <div class="question-text" id="questionText">Calculate the missing value...</div>
                <div class="attempts" id="attemptsText">Attempts remaining: 3</div>
                <div class="input-section">
                    <input type="number" class="answer-input" id="answerInput" placeholder="Your answer" step="any">
                    <select class="unit-select" id="unitSelect">
                        <option value="">Select unit</option>
                        <option value="N">N (Newtons)</option>
                        <option value="m">m (metres)</option>
                        <option value="degrees">¬∞ (degrees)</option>
                    </select>
                    <button class="btn" onclick="checkAnswer()">Submit</button>
                    <button class="btn secondary small" onclick="skipQuestion()">Skip (‚àí10 acc)</button>
                </div>
                <div id="feedback"></div>
            </div>

            <div class="accuracy-gauge">
                <div class="gauge-label">Accuracy Rating</div>
                <div class="gauge-container">
                    <canvas id="gaugeCanvas" width="200" height="120"></canvas>
                </div>
            </div>
        </div>

        <!-- End Screen -->
        <div id="endScreen" class="screen">
            <div class="end-content">
                <h1>üéâ GAME OVER! üéâ</h1>
                <div class="final-score" id="finalScore">0</div>
                <div class="stats-grid">
                    <div class="stat-card"><div class="stat-value" id="questionsAnswered">0</div><div class="stat-label">Questions Seen</div></div>
                    <div class="stat-card"><div class="stat-value" id="correctAnswers">0</div><div class="stat-label">Correct Answers</div></div>
                    <div class="stat-card"><div class="stat-value" id="firstTimeCorrect">0</div><div class="stat-label">First-Time Correct</div></div>
                    <div class="stat-card"><div class="stat-value" id="finalAccuracy">0%</div><div class="stat-label">Final Accuracy</div></div>
                </div>
                <button class="btn" onclick="location.reload()">Play Again!</button>
            </div>
        </div>
    </div>

    <script>
    // ==================== AUDIO ====================
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
        try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            switch(type) {
                case 'correct':
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime+0.1);
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime+0.2);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime+0.35);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime+0.35);
                    break;
                case 'incorrect':
                    oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(160, audioContext.currentTime+0.1);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime+0.25);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime+0.25);
                    break;
                case 'click':
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime+0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime+0.05);
                    break;
                case 'gameEnd':
                    [523.25,659.25,783.99,1046.50].forEach((freq,i) => {
                        const o=audioContext.createOscillator(), g=audioContext.createGain();
                        o.connect(g); g.connect(audioContext.destination);
                        o.frequency.setValueAtTime(freq,audioContext.currentTime+i*0.15);
                        g.gain.setValueAtTime(0.2,audioContext.currentTime+i*0.15);
                        g.gain.exponentialRampToValueAtTime(0.01,audioContext.currentTime+i*0.15+0.3);
                        o.start(audioContext.currentTime+i*0.15);
                        o.stop(audioContext.currentTime+i*0.15+0.3);
                    });
                    break;
            }
        } catch(e){}
    }

    // ==================== GAME STATE ====================
    let gameState = {
        difficulty: 'gcse',
        score: 0,
        questionsAnswered: 0,
        correctAnswers: 0,
        firstTimeCorrect: 0,
        timeRemaining: 300,
        timerInterval: null,
        currentQuestion: null,
        attemptsRemaining: 3,
        accuracyScore: 0,
        previousAnswers: [],
        preferredForceCount: 2
    };

    // ==================== BACKGROUND ====================
    function createBackgroundParticles() {
        const bg = document.getElementById('bgAnimation');
        for (let i=0; i<20; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            const size = Math.random()*50+20;
            p.style.width = size+'px'; p.style.height = size+'px';
            p.style.left = Math.random()*100+'%'; p.style.top = Math.random()*100+'%';
            p.style.animationDelay = Math.random()*20+'s';
            p.style.animationDuration = (Math.random()*10+15)+'s';
            bg.appendChild(p);
        }
    }
    createBackgroundParticles();

    // ==================== SCREEN MANAGEMENT ====================
    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(id).classList.add('active');
    }

    function startGame(difficulty) {
        playSound('click');
        Object.assign(gameState, {
            difficulty, score:0, questionsAnswered:0, correctAnswers:0,
            firstTimeCorrect:0, timeRemaining:300, accuracyScore:0, preferredForceCount:2
        });
        showScreen('gameScreen');
        startTimer();
        generateQuestion();
        drawAccuracyGauge();
    }

    // ==================== TIMER ====================
    function startTimer() {
        const el = document.getElementById('timer');
        gameState.timerInterval = setInterval(() => {
            gameState.timeRemaining--;
            const m = Math.floor(gameState.timeRemaining/60);
            const s = gameState.timeRemaining%60;
            el.textContent = `${m}:${s.toString().padStart(2,'0')}`;
            if (gameState.timeRemaining <= 30) el.classList.add('warning');
            if (gameState.timeRemaining <= 0) endGame();
        }, 1000);
    }

    function endGameEarly() {
        playSound('click');
        showModal('End Game Early?','Are you sure?', () => endGame());
    }

    function skipQuestion() {
        playSound('click');
        gameState.accuracyScore = Math.max(-100, gameState.accuracyScore-10);
        gameState.questionsAnswered++;
        if (gameState.preferredForceCount > 2) gameState.preferredForceCount--;
        drawAccuracyGauge();
        generateQuestion();
    }

    function showModal(title, msg, onConfirm) {
        document.getElementById('modalTitle').textContent = title;
        document.getElementById('modalMessage').textContent = msg;
        document.getElementById('modalOverlay').classList.add('active');
        document.getElementById('modalConfirmBtn').onclick = () => { closeModal(); if(onConfirm) onConfirm(); };
    }
    function closeModal() { document.getElementById('modalOverlay').classList.remove('active'); }

    function endGame() {
        clearInterval(gameState.timerInterval);
        playSound('gameEnd');
        document.getElementById('finalScore').textContent = gameState.score;
        document.getElementById('questionsAnswered').textContent = gameState.questionsAnswered;
        document.getElementById('correctAnswers').textContent = gameState.correctAnswers;
        document.getElementById('firstTimeCorrect').textContent = gameState.firstTimeCorrect;
        const acc = gameState.questionsAnswered > 0 ? Math.round(gameState.correctAnswers/gameState.questionsAnswered*100) : 0;
        document.getElementById('finalAccuracy').textContent = acc+'%';
        showScreen('endScreen');
    }

    // ==================== MATH HELPERS ====================
    /**
     * Compute the SIGNED moment of a force about the pivot.
     * Uses: M = distSign √ó F √ó d √ó cos((beamAngle_deg + fa_deg) √ó œÄ/180)
     * where distSign = +1 for 'right', -1 for 'left'.
     * Positive M = anticlockwise, Negative M = clockwise.
     */
    function signedMoment(f, beamAngle_deg) {
        const distSign = f.side === 'right' ? 1 : -1;
        return distSign * f.magnitude * f.distance *
               Math.cos((beamAngle_deg + f.angleFromVertical) * Math.PI / 180);
    }

    /**
     * Angle (degrees) between force and beam, always 0¬∞‚Äì90¬∞.
     * This is the angle you use in M = F √ó d √ó sin(Œ∏).
     * sin(Œ∏) = |cos((beamAngle + fa) √ó œÄ/180)|
     */
    function getAngleToBeam(fa_deg, beamAngle_deg) {
        // |sin(angleToBeam)| = |cos((fa+b)*œÄ/180)|
        return Math.asin(Math.min(1, Math.abs(Math.cos((fa_deg + beamAngle_deg) * Math.PI / 180)))) * 180 / Math.PI;
    }

    // ==================== QUESTION GENERATION ====================
    const MAX_RETRIES = 15;
    let _retryCount = 0;

    function generateQuestion() {
        if (_retryCount > MAX_RETRIES) {
            _retryCount = 0;
        }

        // Reset UI
        gameState.attemptsRemaining = 3;
        gameState.previousAnswers = [];
        document.getElementById('answerInput').value = '';
        document.getElementById('unitSelect').value = '';
        document.getElementById('feedback').innerHTML = '';
        document.getElementById('attemptsText').textContent = 'Attempts remaining: 3';
        document.getElementById('attemptsText').classList.remove('low');

        const isGCSE = gameState.difficulty === 'gcse';
        // Beam angle: 0 for GCSE, small tilt for A-level
        const beamAngle = isGCSE ? 0 : (Math.floor(Math.random() * 7 - 3) * 5); // -15, -10, -5, 0, 5, 10, 15
        const numForces = gameState.preferredForceCount;

        // -- Generate forces --
        const forces = [];
        const zoneWidth = 1.6 / numForces;

        for (let i = 0; i < numForces; i++) {
            const side = (i % 2 === 0) ? 'right' : 'left';
            // Zone-based distance to prevent bunching
            const zoneCenter = 0.3 + i * zoneWidth + zoneWidth / 2;
            const maxVariation = zoneWidth * 0.35;
            const distance = Math.round((zoneCenter + (Math.random() * 2 - 1) * maxVariation) * 100) / 100;

            let fa;
            if (isGCSE) {
                // Always perpendicular: up or down
                fa = Math.random() < 0.5 ? 0 : 180;
            } else {
                // A-level: angle to beam in 35¬∞‚Äì75¬∞ range for a clean diagram
                const angleToBeam = 35 + Math.random() * 40; // 35¬∞ to 75¬∞
                const isDown = Math.random() < 0.5;
                // fa = 90 - angleToBeam - beamAngle (up), or add 180 for down
                fa = (90 - angleToBeam - beamAngle) + (isDown ? 180 : 0);
            }

            forces.push({
                magnitude: Math.round(20 + Math.random() * 80), // 20‚Äì100 N, integer
                distance: Math.max(0.20, distance),
                angleFromVertical: fa,
                side: side
            });
        }

        // -- Pick question type and missing index --
        const questionTypes = isGCSE ? ['force', 'distance'] : ['force', 'distance', 'angle'];
        const questionType = questionTypes[Math.floor(Math.random() * questionTypes.length)];
        const missingIndex = Math.floor(Math.random() * numForces);

        // -- Compute sum of moments for all OTHER forces --
        let sumOther = 0;
        forces.forEach((f, idx) => {
            if (idx !== missingIndex) sumOther += signedMoment(f, beamAngle);
        });

        const distSign_m = forces[missingIndex].side === 'right' ? 1 : -1;
        let answer;

        if (questionType === 'force') {
            // Required: distSign_m √ó F_m √ó d_m √ó cos((b+fa_m)√óœÄ/180) = ‚àísumOther
            const cosVal = Math.cos((beamAngle + forces[missingIndex].angleFromVertical) * Math.PI / 180);
            const denom = distSign_m * forces[missingIndex].distance * cosVal;

            if (Math.abs(denom) < 0.05) { _retryCount++; return generateQuestion(); }

            answer = -sumOther / denom;

            // If negative, flip force direction to make it physically possible
            if (answer < 0) {
                forces[missingIndex].angleFromVertical = (forces[missingIndex].angleFromVertical + 180) % 360;
                const c2 = Math.cos((beamAngle + forces[missingIndex].angleFromVertical) * Math.PI / 180);
                answer = -sumOther / (distSign_m * forces[missingIndex].distance * c2);
            }

            if (answer < 5 || answer > 250) { _retryCount++; return generateQuestion(); }
            forces[missingIndex].magnitude = answer;

        } else if (questionType === 'distance') {
            const cosVal = Math.cos((beamAngle + forces[missingIndex].angleFromVertical) * Math.PI / 180);
            const denom = distSign_m * forces[missingIndex].magnitude * cosVal;

            if (Math.abs(denom) < 0.1) { _retryCount++; return generateQuestion(); }

            answer = -sumOther / denom;

            if (answer < 0) {
                // Flip side
                forces[missingIndex].side = forces[missingIndex].side === 'right' ? 'left' : 'right';
                const ds2 = forces[missingIndex].side === 'right' ? 1 : -1;
                answer = -sumOther / (ds2 * forces[missingIndex].magnitude * cosVal);
            }

            if (answer < 0.10 || answer > 3.0) { _retryCount++; return generateQuestion(); }
            forces[missingIndex].distance = answer;

        } else { // 'angle' (A-level only)
            // Required: distSign_m √ó F_m √ó d_m √ó cos((b+fa_m)√óœÄ/180) = ‚àísumOther
            // cos((b+fa_m)√óœÄ/180) = ‚àísumOther / (distSign_m √ó F_m √ó d_m)
            const cosNeeded = -sumOther / (distSign_m * forces[missingIndex].magnitude * forces[missingIndex].distance);

            if (Math.abs(cosNeeded) > 0.97 || Math.abs(cosNeeded) < 0.10) {
                _retryCount++; return generateQuestion();
            }

            // The angle the force makes with the beam: sin(angleToBeam) = |cosNeeded|
            const angleToBeam = Math.asin(Math.abs(cosNeeded)) * 180 / Math.PI;
            answer = Math.round(angleToBeam * 10) / 10; // answer in degrees

            // Recover fa from cosNeeded:
            // cos((b + fa) √ó œÄ/180) = cosNeeded
            // (b + fa) = arccos(cosNeeded) in degrees
            const bPlusFa = Math.acos(cosNeeded) * 180 / Math.PI;
            forces[missingIndex].angleFromVertical = bPlusFa - beamAngle;
        }

        _retryCount = 0;

        // -- Store question --
        const forceLabel = String.fromCharCode(65 + missingIndex);
        gameState.currentQuestion = {
            beamAngle, forces, questionType, missingIndex, answer,
            unit: questionType === 'force' ? 'N' : (questionType === 'distance' ? 'm' : 'degrees'),
            numForces
        };

        const questionTexts = {
            force:    `Find the magnitude of Force ${forceLabel}`,
            distance: `Find the distance from the pivot to Force ${forceLabel}`,
            angle:    `Find the angle Force ${forceLabel} makes with the beam`
        };
        document.getElementById('questionText').textContent = questionTexts[questionType];

        drawQuestion();
    }

    // ==================== COLORS ====================
    const forceColors = ['#E71D36','#2EC4B6','#F7B801','#9C27B0','#FF6B35'];

    // ==================== DRAWING ====================
    // Hit areas for hover detection
    let forceHitAreas = [];

    function drawQuestion() {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const q = gameState.currentQuestion;
        const isGCSE = gameState.difficulty === 'gcse';
        const centerX = canvas.width / 2 + 20;
        const centerY = canvas.height / 2 + 20;
        const beamHalfLen = 300;
        const bRad = q.beamAngle * Math.PI / 180;

        const bSX = centerX - beamHalfLen * Math.cos(bRad);
        const bSY = centerY - beamHalfLen * Math.sin(bRad);
        const bEX = centerX + beamHalfLen * Math.cos(bRad);
        const bEY = centerY + beamHalfLen * Math.sin(bRad);

        // Draw beam
        ctx.strokeStyle = '#004E89';
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(bSX, bSY);
        ctx.lineTo(bEX, bEY);
        ctx.stroke();

        // Draw pivot (upward triangle beneath beam)
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(bRad);
        ctx.fillStyle = '#1A1A2E';
        ctx.beginPath();
        ctx.moveTo(-14, 28); ctx.lineTo(14, 28); ctx.lineTo(0, 5);
        ctx.closePath(); ctx.fill();
        // Ground line
        ctx.fillStyle = '#555';
        ctx.fillRect(-22, 28, 44, 5);
        ctx.restore();

        // Reset hit areas
        forceHitAreas = [];

        // Draw each force
        q.forces.forEach((force, idx) => {
            const isMissing = idx === q.missingIndex;
            const color = forceColors[idx % forceColors.length];
            const label = String.fromCharCode(65 + idx);

            // Position along beam
            const dist_px = force.distance * 100;
            const signedDist = force.side === 'right' ? dist_px : -dist_px;
            const fx = centerX + signedDist * Math.cos(bRad);
            const fy = centerY + signedDist * Math.sin(bRad);

            // Tick mark on beam at force point
            ctx.save();
            ctx.translate(fx, fy);
            ctx.rotate(bRad + Math.PI / 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-7, 0); ctx.lineTo(7, 0);
            ctx.stroke();
            ctx.restore();

            // Arrow: uniform length 85px
            const arrowLen = 85;
            const faRad = force.angleFromVertical * Math.PI / 180;

            // Force direction in canvas: tip offset from base
            const tipDx = -Math.sin(faRad) * arrowLen;
            const tipDy = -Math.cos(faRad) * arrowLen;
            const tipX = fx + tipDx;
            const tipY = fy + tipDy;

            // Store midpoint for hover
            forceHitAreas.push({
                x: fx + tipDx / 2,
                y: fy + tipDy / 2,
                idx
            });

            // Arrow shaft
            ctx.save();
            ctx.translate(fx, fy);
            ctx.rotate(-faRad);
            ctx.strokeStyle = color;
            ctx.lineWidth = (isMissing && q.questionType === 'force') ? 3 : 5;
            ctx.setLineDash((isMissing && q.questionType === 'force') ? [8, 5] : []);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -arrowLen + 14);
            ctx.stroke();
            ctx.setLineDash([]);

            // Arrowhead
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, -arrowLen);
            ctx.lineTo(-9, -arrowLen + 17);
            ctx.lineTo(9, -arrowLen + 17);
            ctx.closePath();
            ctx.fill();

            // Label at MIDPOINT of arrow shaft, offset to the right (perpendicular)
            // Perpendicular direction in local frame: (1, 0) when un-rotated ‚Üí to the right
            // In world coords, un-rotate and draw
            ctx.translate(0, -arrowLen / 2);
            ctx.rotate(faRad); // un-rotate to keep text readable
            ctx.fillStyle = color;
            ctx.font = 'bold 16px Nunito, sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            // Determine which side to put label based on arrow direction to avoid beam overlap
            const labelOffset = 13;
            // Background pill
            const labelW = ctx.measureText(label).width + 10;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillRect(labelOffset - 2, -10, labelW, 20);
            ctx.fillStyle = color;
            ctx.fillText(label, labelOffset + 3, 0);

            ctx.restore();

            // Draw angle arc (for A-level, or if GCSE and showing the concept visually)
            if (!isGCSE) {
                const angleToBeam = getAngleToBeam(force.angleFromVertical, q.beamAngle);
                const arcLabel = (isMissing && q.questionType === 'angle') ? '?' : angleToBeam.toFixed(1) + '¬∞';
                drawAngleArc(ctx, fx, fy, bRad, faRad, force.side, arcLabel, color);
            }
        });

        // Build force table
        buildForceTable(q, isGCSE);
    }

    /**
     * Draw arc showing the angle between force and the nearest end of the beam.
     * The arc angle always matches the "angle to beam" value shown in the table
     * (i.e. always the ACUTE angle, 0¬∞‚Äì90¬∞).
     *
     * @param {number} bRad  - beam angle in canvas radians (0 = right)
     * @param {number} faRad - force.angleFromVertical in radians
     * @param {string} side  - 'right' or 'left' (preferred outward beam direction)
     * @param {string} label - text to display (e.g. "40.0¬∞" or "?")
     */
    function drawAngleArc(ctx, x, y, bRad, faRad, side, label, color) {
        ctx.save();
        ctx.translate(x, y);

        const arcRadius = 32;

        // Force direction in canvas (angle from +x axis, clockwise positive)
        const forceDir = -Math.PI / 2 - faRad;

        // Try both ends of the beam; pick the one that gives the smaller (acute) arc
        const beamDirA = bRad;           // outward end
        const beamDirB = bRad + Math.PI; // opposite end

        function normDiff(a, b) {
            let d = a - b;
            while (d >  Math.PI) d -= 2 * Math.PI;
            while (d < -Math.PI) d += 2 * Math.PI;
            return d;
        }

        const diffA = normDiff(forceDir, beamDirA);
        const diffB = normDiff(forceDir, beamDirB);

        // Choose the beam direction that gives the smaller arc (acute angle)
        const usedBeamDir = Math.abs(diffA) <= Math.abs(diffB) ? beamDirA : beamDirB;
        const diff = Math.abs(diffA) <= Math.abs(diffB) ? diffA : diffB;

        // Draw dashed reference line along the chosen beam direction
        ctx.strokeStyle = color;
        ctx.setLineDash([4, 4]);
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.55;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(arcRadius * 1.7 * Math.cos(usedBeamDir), arcRadius * 1.7 * Math.sin(usedBeamDir));
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1.0;

        // Arc from chosen beam direction to force direction
        const counterclockwise = diff < 0;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(0, 0, arcRadius, usedBeamDir, forceDir, counterclockwise);
        ctx.stroke();

        // Label at midpoint of arc
        const midDir = usedBeamDir + diff / 2;
        const labelR = arcRadius + 16;
        const lx = labelR * Math.cos(midDir);
        const ly = labelR * Math.sin(midDir);

        ctx.font = 'bold 13px Nunito, sans-serif';
        const tw = ctx.measureText(label).width;
        ctx.fillStyle = 'rgba(255,255,255,0.88)';
        ctx.fillRect(lx - tw/2 - 3, ly - 9, tw + 6, 18);
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, lx, ly);

        ctx.restore();
    }

    // ==================== FORCE TABLE ====================
    function buildForceTable(q, isGCSE) {
        const tbody = document.getElementById('forceTableBody');
        tbody.innerHTML = '';

        q.forces.forEach((f, idx) => {
            const isMissing = idx === q.missingIndex;
            const color = forceColors[idx % forceColors.length];
            const label = String.fromCharCode(65 + idx);

            const angleToBeam = getAngleToBeam(f.angleFromVertical, q.beamAngle);

            const distVal  = (isMissing && q.questionType === 'distance') ? null : f.distance;
            const angleVal = (isMissing && q.questionType === 'angle')    ? null : angleToBeam;
            const magVal   = (isMissing && q.questionType === 'force')    ? null : f.magnitude;

            const fmt = (v, decimals=2) => v === null
                ? `<span class="missing-val">?</span>`
                : `<span class="known-val">${typeof v === 'number' ? v.toFixed(decimals) : v}</span>`;

            const tr = document.createElement('tr');
            tr.dataset.forceIdx = idx;
            tr.innerHTML = `
                <td>
                  <div class="force-label-cell">
                    <span class="force-color-dot" style="background:${color}"></span>
                    <strong style="color:${color}">${label}</strong>
                  </div>
                </td>
                <td>${fmt(distVal, 2)}</td>
                <td>${fmt(angleVal, 1)}</td>
                <td>${fmt(magVal, 1)}</td>
            `;
            tbody.appendChild(tr);
        });
    }

    // ==================== HOVER DETECTION ====================
    const canvas = document.getElementById('gameCanvas');

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mx = (e.clientX - rect.left) * scaleX;
        const my = (e.clientY - rect.top) * scaleY;

        let hoveredIdx = -1;
        let minDist = 45; // pixels threshold

        forceHitAreas.forEach(ha => {
            const d = Math.hypot(mx - ha.x, my - ha.y);
            if (d < minDist) { minDist = d; hoveredIdx = ha.idx; }
        });

        document.querySelectorAll('#forceTableBody tr').forEach(row => {
            row.classList.toggle('highlighted', parseInt(row.dataset.forceIdx) === hoveredIdx);
        });
    });

    canvas.addEventListener('mouseleave', () => {
        document.querySelectorAll('#forceTableBody tr').forEach(row => row.classList.remove('highlighted'));
    });

    // ==================== ANSWER CHECKING ====================
    function roundToSigFigs(num, sigFigs) {
        if (num === 0) return 0;
        const mag = Math.floor(Math.log10(Math.abs(num)));
        const factor = Math.pow(10, sigFigs - mag - 1);
        return Math.round(num * factor) / factor;
    }

    function countSigFigs(numStr) {
        const cleaned = numStr.replace(/^0+/, '').replace('.', '');
        return cleaned.replace(/^0+/, '').length;
    }

    function checkAnswer() {
        playSound('click');
        const userAnswer = parseFloat(document.getElementById('answerInput').value);
        const userUnit   = document.getElementById('unitSelect').value;
        const { answer: correctAnswer, unit: correctUnit } = gameState.currentQuestion;
        const feedbackDiv = document.getElementById('feedback');

        if (isNaN(userAnswer)) {
            feedbackDiv.innerHTML = '<div class="feedback incorrect">Please enter a number!</div>';
            return;
        }
        if (!userUnit) {
            feedbackDiv.innerHTML = '<div class="feedback incorrect">Please select a unit!</div>';
            return;
        }

        const sigFigs = countSigFigs(document.getElementById('answerInput').value.trim());
        if (sigFigs < 2) {
            gameState.attemptsRemaining--;
            updateAttemptsDisplay();
            feedbackDiv.innerHTML = '<div class="feedback incorrect">‚ùå Give your answer to at least 2 significant figures!</div>';
            if (gameState.attemptsRemaining === 0) handleIncorrect(true);
            return;
        }

        gameState.previousAnswers.push({ answer: userAnswer, unit: userUnit });

        if (userUnit !== correctUnit) {
            gameState.attemptsRemaining--;
            updateAttemptsDisplay();
            feedbackDiv.innerHTML = `<div class="feedback incorrect">‚ùå Wrong unit! You need ${correctUnit}.</div>`;
            playSound('incorrect');
            if (gameState.attemptsRemaining === 0) handleIncorrect(true);
            return;
        }

        const userR    = roundToSigFigs(userAnswer, 2);
        const correctR = roundToSigFigs(correctAnswer, 2);

        if (Math.abs(userR - correctR) / Math.max(Math.abs(correctR), 0.01) < 0.02) {
            handleCorrect();
        } else {
            gameState.attemptsRemaining--;
            updateAttemptsDisplay();
            feedbackDiv.innerHTML = `<div class="feedback incorrect">‚ùå ${generateHint(userAnswer, correctAnswer)}</div>`;
            playSound('incorrect');
            if (gameState.attemptsRemaining === 0) handleIncorrect(true);
        }
    }

    function updateAttemptsDisplay() {
        const el = document.getElementById('attemptsText');
        el.textContent = `Attempts remaining: ${gameState.attemptsRemaining}`;
        if (gameState.attemptsRemaining <= 1) el.classList.add('low');
    }

    function generateHint(userAnswer, correctAnswer) {
        const ratio = userAnswer / correctAnswer;
        if (ratio > 0.9 && ratio < 1.1) return "Very close! Check rounding carefully.";
        if (Math.abs(ratio - 2) < 0.15) return "Your answer is about twice too large ‚Äî did you forget a division?";
        if (Math.abs(ratio - 0.5) < 0.1) return "Your answer is about half ‚Äî did you divide instead of multiply?";
        if (gameState.currentQuestion.questionType === 'angle')
            return "Check your trig: use sin(Œ∏) for the perpendicular component.";
        if (userAnswer > correctAnswer * 1.5) return "Too high ‚Äî double-check your calculation.";
        if (userAnswer < correctAnswer * 0.5) return "Too low ‚Äî make sure you're using all the forces.";
        return "Not quite. Remember: sum of clockwise moments = sum of anticlockwise moments.";
    }

    function handleCorrect() {
        playSound('correct');
        const isFirstAttempt = gameState.attemptsRemaining === 3;
        const numForces = gameState.currentQuestion.numForces;
        const basePoints = isFirstAttempt ? 100 : (gameState.attemptsRemaining === 2 ? 60 : 30);
        const points = basePoints + (numForces - 2) * 20;
        gameState.score += points;
        document.getElementById('score').textContent = gameState.score;
        gameState.questionsAnswered++;
        gameState.correctAnswers++;
        if (isFirstAttempt) {
            gameState.firstTimeCorrect++;
            gameState.accuracyScore = Math.min(100, gameState.accuracyScore + 10);
            if (gameState.preferredForceCount < 5) gameState.preferredForceCount++;
        } else {
            gameState.accuracyScore = Math.max(-100, gameState.accuracyScore - 5);
        }
        const messages = ['Excellent!','Perfect!','Brilliant!','Outstanding!','Superb!'];
        document.getElementById('feedback').innerHTML =
            `<div class="feedback correct">‚úÖ ${messages[Math.floor(Math.random()*messages.length)]} +${points} points!</div>`;
        drawAccuracyGauge();
        setTimeout(() => generateQuestion(), 2000);
    }

    function handleIncorrect(showAnswer = false) {
        gameState.questionsAnswered++;
        gameState.accuracyScore = Math.max(-100, gameState.accuracyScore - 15);
        if (showAnswer) {
            const { answer, unit } = gameState.currentQuestion;
            document.getElementById('feedback').innerHTML =
                `<div class="feedback incorrect">‚ùå Out of attempts! Answer: ${answer.toFixed(2)} ${unit}</div>`;
            drawAccuracyGauge();
            setTimeout(() => generateQuestion(), 3000);
        }
    }

    // ==================== ACCURACY GAUGE ====================
    function drawAccuracyGauge() {
        const canvas = document.getElementById('gaugeCanvas');
        const ctx = canvas.getContext('2d');
        const cx = canvas.width / 2, cy = canvas.height - 10, r = 78;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const sections = [
            { start: Math.PI,               end: Math.PI + Math.PI/3,     color: '#E71D36' },
            { start: Math.PI + Math.PI/3,   end: Math.PI + 2*Math.PI/3,   color: '#F7B801' },
            { start: Math.PI + 2*Math.PI/3, end: 2*Math.PI,               color: '#2EC4B6' }
        ];
        ctx.lineWidth = 14;
        sections.forEach(s => {
            ctx.strokeStyle = s.color;
            ctx.beginPath();
            ctx.arc(cx, cy, r, s.start, s.end, false);
            ctx.stroke();
        });

        const normalised = (gameState.accuracyScore + 100) / 200;
        const needleAngle = Math.PI + normalised * Math.PI;
        ctx.strokeStyle = '#1A1A2E';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + (r - 10) * Math.cos(needleAngle), cy + (r - 10) * Math.sin(needleAngle));
        ctx.stroke();
        ctx.fillStyle = '#1A1A2E';
        ctx.beginPath();
        ctx.arc(cx, cy, 7, 0, 2*Math.PI);
        ctx.fill();
    }

    // ==================== KEYBOARD SUPPORT ====================
    document.getElementById('answerInput').addEventListener('keypress', e => {
        if (e.key === 'Enter') checkAnswer();
    });

    window.addEventListener('load', () => drawAccuracyGauge());
    </script>
</body>
</html>
